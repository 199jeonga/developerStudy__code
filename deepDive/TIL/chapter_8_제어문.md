# 제어문

조건에 따라 코드문을 실행(조건문)하거나 반복실행(반복문)할 때 사용한다.
일반적으로 코드는 순차적으로 진행되지만 제어문을 활용하면 실행 흐름을 제어할 수 있다. 하지만 이는 코드의 가독성을 떨어트리기 때문에 사용에 주의해야 한다.

## 블록문

0개 이상의 문을 중괄호로 묶은 것으로 코드 블록 또는 블록이라고 부름 -> 하나의 실행 단위로 취급

- 단독 사용이 가능하지만 일반적으론 제어문이나 함수를 정의할 때 사용
- 블록문은 자체종결성을 갖기 떄문에 `;`을 붙이지 않는다.

## 조건문

주어진 조건식의 평가 결과에 따라 코드 블록의 실행을 결정
조건식은 불리언값으로 평가될 수 있는 표현식이다. -> 만약 불리언값이 아닌 값으로 평가되면 암묵적 타입변환이 이루어진다.

### if...else문

논리적 참 or 거짓에 따라 실행할 코드 블록을 결정한다.

```js
if (조건식) {
  // 조건식이 참이면 이 코드 블록이 실행된다.
} else {
  //조건식이 거짓이면 이 코드 블록이 실행된다.
}
```

```js
if(조건식1){
  //조건식 1이 참이면 이 코드블록이 실행된다.
}else if(조건식2){
  //조건식 2가 참이면 이 코드블록이 실행된다.
}else{
  조건이 모두 거짓이면 이 코드 블록이 실행된다.
}
```

- 만약 코드 블록 내 문이 하나면 중괄호를 생략할 수 있다!!

```js
//중괄호 생략
var num = 2;
var kind;

if (num > 0) kind = "양수";
else if (num < 0) kind = "음수";
else kind = "영";

console.log(kind); //양수
```

- 대부분의 if...else문은 삼항 조건연산자로 바꿔 쓸 수 있다.

```js
var kind = num ? (num > 0 ? "양수" : "음수") : "영"; // 0은 false로 암묵적 타입변환이 이루어진다.
```

- 삼항 조건연산자는 값으로 평가되는 표현식을 만든다. (표현식은 값처럼 사용할 수 있기 때문에 변수에 할당 가능!)
- if...else문은 표현식이 아닌 문이다. 값처럼 사용할 수 없기 때문에 변수에 할당할 수 없다.

## switch문

주어진 표현식을 평가하여 그 값과 일치하는 표현식을 갖는 case문으로 실행을 옮긴다.
switch문과 일치하는 case문이 없다면 default문으로 이동한다. (선택사항)

```js
switch(표현식){
  case 표현식1 :
    switch 문의 표현식과 표현식 1이 일치하면 실행될 문;
  break;
  case 표현식2 :
    switch 문의 표현식과 표현식 2이 일치하면 실행될 문;
  break;
  default :
    switch 문의 표현식과 일치하는 case문이 없을 때 실행될 문;
}
```

- switch문의 case문은 문자값이나 숫자값의 경우가 많다.
- 다양한 상황에 따라 실행할 코드블록을 결정할 때 사용
- `break;`를 작성하지 않는다면 동일한 case문을 발견해도 해당 case문을 빠져나오지 않은 채로 다음 case문에 재할당을 반복하며 마지막 case문 혹은 default문의 값이 도출된다. -> <b><i>폴스루</i></b>라고 함!!!
- default문에는 break; 문을 생략하는 것이 일반적이다. (switch문 가장 마지막에 위치하기 때문에 default문이 종료되면 switch문을 빠져나간다.)

## 반복문

조건식의 결과가 참인 경우 코드 블록 실행, 을 반복한다.

### for문

조건식이 거짓으로 평가될 때까지 코드블록 반복 실행

```js
for(변수 선언문 또는 할당문 ; 조건식 ; 증감식){
  조건식이 참인 경우 실행된다.
}
```

변수 선언문(은 한 번만 실행된다.) -> 조건식 실행 -> 코드 블록 실행 -> 증감식 실행 -> 조건식 실행 -> 코드블록 실행 -> 증감식 실행 -> 조건식 실행(=== false for문 종료)
의 순서로 진행된다.

- 조건식 -> 코드블록 -> 증감식의 순서로 진행된다.
- 선언문은 한 번만 실행된다.
- 선언문, 조건식, 증감식은 선택사항이나 모두 작성하지 않는다면 코드블록이 계속반복되는 무한루프에 빠지게 된다.
- for문 내부에 for문을 작성할 수 있다 -> 중첩for문

### while문

- 조건식 평가 결과가 참이면 코드블록을 반복 실행한다.
- for문은 반복횟구가 명확할 때 주로 사용 / while은 반복횟수가 불명확할 때 주로 사용
- 조건식의 평과 결과가 불리언 값이 아니라면 강제변환하여 참, 거짓 구별
- 조건식의 결과가 항상 참이면 무한루프에 빠지므로 주의해야 한다

```js
var count = 0;
while (count < 3) {
  console.log(count);
  count++;
}
```

```js
while (true) {
  //무한루프
  console.log(count);
  count++;
  if (count === 3) break; //조건문과 break문을 사용하여 무한루프 바져나오기
}
```

### do...while문

- 코드블록을 먼저!!! 실행하고 조건식을 평가한다. 코드블록이 무조건 한 번 이상 실행된다.

```js
do {
  console.log(count);
  count++;
} while (count < 3);
```

### break문

- 코드 블록을 탈출한다. (레이블 문, 반복문, switch문의 코드 블록을 탈출 이 외에 사용하면 문법에러 발생)

<b>레이블문</b>

- 레이블문이란 식별자가 붙은 문을 말한다 `foo : console.log('foo');`
- 레이블문은 실행순서를 제어하는데 사용한다. (switch의 case, default도 레이블문)
- 레이블문을 종료하기 위해서는 break문에 레이블 식별자를 지정한다.

- 중첩된 for문의 내부에서 break문을 실행하면 내부 for문을 탈출하여 외부 for문으로 진입한다.
- 만약 외부 for문을 탈출하고자 한다면 레이블 문을 사용한다.

```js
outer: for (var i = 0; i < 3; i++) {
  for (var j = 0; j < 3; j++) {
    if (i + j === 3) break outer; // 레이블을 사용하여 외부 for문을 종료하였다.
    console.log(`inner ${i}, ${j}`);
  }
}
```

- 문자열은 유사배열이기 때문에 for문을 돌릴 수 있다.
- 문자열에서 특장 문자의 인덱스 위치 검색하기

```js
var string = "hello World";
var search = "l";
var index;

for (var i = 0; i < string.length; i++) {
  if (string[i] === search) {
    index = i;
    break;
  }
}
// string.indexOf(search) 메서드를 사용해도 같은 결과가 도출된다.
```

## continue문

- 박복문의 코드 블록을 현 지점에서 중단 -> 반복문의 증감식으로 실행 흐름 이동
- 반복문을 탈출하지는 않는다. (식의 흐름을 증가식으로 이동만 할 뿐!!)

```js
var string = "hello world.";
var search = "l";
var count = 0;

//문자열은 유사배열이기 때문에 for문을 순회할 수 있다!
for (var i = 0; i < string.length; i++) {
  if (string[i] !== search) continue; // 'hello world.' 의 개별 요소가 'l' 와 같지 않다면 실행을 중단하고 반복문의 증감식으로 이동
  count++; // if문의 조건이 일치하지 않는다면(같다면) count에 1을 더한다.
}

// if문 내 코드가 한줄이라면 continue가 아닌 일반 반복문을 사용하는 것이 가독성이 좋다. -> 코드블록을 사용하여 한 번 더 들여쓰기 해야함
for (var i = 0; i < string.length; i++) {
  if (string[i] === search) count++;
}

//String.prototype.match 메서드를 사용해도 같은 동작을 한다.
// const regexp = new RegExp(search, 'g');
// console.log(string.match(regexp).length)
```
