# 모던자바스크립트 DEEPDIVE - chapter 11 원시 값과 객체의 비교

자바스크립트가 제공하는 7가지 데이터 타입은 크게 원시타입과 객체타입으로 구분할 수 있다.

- 원시 타입은 변경 불가능한 값
- 객체 타입은 변경 가능한 값

- 원시 값을 변수에 할당하면 변수에는 실제 값이 저장된다.
- 객체를 변수에 할당하면 변수에는 참조 값이 저장된다.

- 원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 원시값이 복사되어 전달 → 값에 의한 전달
- 객체를 가리키는 변수를 다른 변수에 할당하면 참조값이 복사되어 전달 → 참조에 의한 전달

# 원시값

## 변경 불가능한 값

원시값은 변경 불가능한 값이기 때문에 한 번 생성된 원시값은 **읽기 전용 값으로 변경할 수 없다.**

변수

- 하나의 값을 저장하기 위해 확보한 메모리 공간 자체
- 메모리 공간을 식별하기 위해 붙인 이름

값

- 저장된 데이터로서 표현식이 평가되어 생성된 결과

→ 변경 불가능하다는 것은 변수가 아닌 **값에 대한 진술**

→ 원시 값 자체를 변경할 수 없다는 것이지 변수 값을 변경할 수 없다는 것은 아님!!! 변수는 언제든 재할당을 통해 변수값을 변경할 수 있다.

```jsx
// const 키워드를 사용해 사용한 변수는 재할당이 금지된다.
// 상수는 재할당이 금지된 변수!일 뿐이다.
const o = {};

o.a = 1; //{a:1]
```

원시값은 읽기 전용이다. → 데이터 신뢰성을 보장

- 원시값을 할당한 변수에 새로운 원시값을 재할당하면 메모리 공간에 저장되어 있는 재할당 이전의 원시값을 변경하는 것이 아닌 **새로운 메모리 공간을 확보하고 재할당한 원시값을 저장한 후 변수는 새롭게 재할당한 원시값을 가리킨다.**
  - 불변성 : 변수가 참조하던 메모리 공간의 주소가 바뀐다!! ← 원시값이 변경 불가능한 값이기 때문
  - 불변성을 갖는 원시값을 할당한 변수는 재할당 이외에 변수값을 변경할 수 있는 방법이 없다!

## 문자열과 불변성

원시값을 저장하려면 확보해야 하는 메모리 공간의 크기를 결정해야 한다. (ECMAScript 사양에 문자열과 숫자타입 외의 원시타입은 크기가 명확히 규정되어 있지않기 때문에 원시타입의 크기는 다를 수 있다.)

문자열

- 0개 이상의 문자로 이뤄진 집합을 말하며 1개의 문자는 2바이트의 메모리 공간에 저장된다. → 몇개의 문자로 이뤄졌는지에 따라 메모리 공간의 크기가 결정된다.
  - `“”` 0개의 문자로 이뤄진 문자열
  - `“Hi”` 2개의 문자로 이뤄진 문자열

```jsx
var str = "Hello";
srt = "world";
```

1. 첫번째 문이 실행되면 Hello 문자열이 생성됨
2. 식별자 str은 문자열 Hello가 저장된 메모리 공간의 첫번째 메모리 셀 주소를 가리킨다.
3. 두번째 문이 실행되면 새로운 문자열 world를 메모리에 생성함
4. 식별자 str은 새로 생성된 world문자열을 가리킨다.

- 문자열 “Hell”, “world”는 모두 메모리에 존재한다.
- 식별자 str이 가리키는 값이 달라졌을 뿐이다.

문자열은 유사배열 객체이면서 이터러블이므로 배열과 유사하게 각 문자에 접근할 수 있다.

`유사 배열 객체 : 마치 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고 length프로퍼티를 갖는 객체 + for문으로 순회 가능`

```jsx
var str = "string";

//문자열은 유사 배열이므로 배열과 유사하게 인덱스를 사용해 각 문자에 접근할 수 있다.
console.log(str[0]); //s

// 원시값인 문자열이 객체처럼 동작한다.
str.length; //6
srt.toUpperCase; //STRING
```

```jsx
vr str = 'string';
str[0] = 'S';
console.log(str) //"string"
```

- 문자열은 유사배열이므로 인덱스를 사용해 각 문자에 접근할 수 있다.
- 하지만 원시값이므로 변경할 수 없다!!!
  - 하지만!!! 바꿔도 에러가 발생하지 않는다.

한번 생성된 문자열은 읽기 전용 값으로 변경할 수 없다. → 따라서 예기치 못한 변경으로부터 자유롭기 때문에 데이터 신뢰성을 보장한다.

그러나 변수에 새로운 문자열을 재할당하는 것은 가능하다. (기존 문자열 변경이 아닌 새로운 문자열을 새롭게 할당하는 것이기 때문!!!!)

## 값에 의한 전달

변수에 변수를 할당했을 때, 무엇이 어떻게 전달되는지 확인

```jsx
var a = 90;
var b = a;
//a = 90, b = 90;

a = 100;
//a = 100, b = 90;
```

a = b에서 a는 변수값 90으로 평가되므로 b는 새로운 숫자값 90이 생성되어 copy변수에 할당된다.

- 변수의 원시값을 갖는 변수를 할당하면 **원시값이 복사되어 전달된다.→ 값에 의한 전달**

```jsx
var a = 90;
var b = a;
a === b; // true
```

- a와 b의 값은 동일하지만, 다른 메모리 공간에 저장된 별개의 값이다.

```jsx
var a = 90;
var b = a;
a === b; // true

a = 100;
a === b; // a=100, b=90, flase
```

a,b 변수의 값이 다른 메모리 공간에 저장된 별개의 값이라는 것에 주의하며, (원본이었던)a의 값을 변경해도 b에는 영향을 주지 않는다.

- 파이썬은 같은 메모리 공간을 참조하다 어느 한 변수에 재할당이 이루어졌을 때 새로운 메모리 공간에 재할당된 값을 저장한다.

**ECMAScript 사양엔 값에 의한 전달이라는 용어가 존재하지 않는다. (타언어에서 주로 사용)**

- 엄격하게 표현하자면 변수엔 값이 전달되는 것이 아닌 메모리 주소가 전달되기 때문, 변수와 같은 식별자는 값이 아닌 메모리 주소를 기억하고 있다.

**식별자는 어떤 값을 구별해서 식별해낼 수 있는 고유한 이름**

→ 값은 메모리 공간에 저장되어 있다. 따라서 식별자는 메모리 공간에 저장되어 있는 어떤 값을 구별해서 식별해낼 수 있어야 하므로 값이 아닌 메모리 주소를 기억하고 있다.

`var x = 10;` 할당 연산자는 숫자 리터럴 10에 의해 생성된 **숫자 값 10이 저장된 메모리 공간의 주소를 전달**한다. → 식별자 x는 메모리 공간에 저장된 숫자값 10을 식별할 수 있다.

`var copy = score` 식별자 표현식으로서 숫자값으로 평가된다.

- 새로운 숫자값을 생성하여 메모리 주소를 전달 → 할당시점에 두 변수가 기억하는 메모리 주소가 다르다.
- score의 변수값 메모리 주소를 그대로 전달하는 방식 → 할당 시점에 두 변수가 기억하는 메모리 주소가 같다.

**이처럼 값에 의한 전달도 사실은 값을 전달하는 것이 아닌 메모리 주소를 전달한다.** 단!! 전달된 메모리 주소를 통해 메모리 공간에 접근하면 값을 참조할 수 있다.

# 객체

- 프로퍼티 개수가 정해져 있지 않다
- 동적으로 추가, 삭제가 가능하다.
- 프로퍼티 값에 제약이 없다. → 원시값과 같이 확보해야할 메모리 공간의 크기를 사전에 정해둘 수 없다!!

**_자바스크립트 객체의 관리 방식_**

자바스크립트 객체는 **프로퍼티 키를 인덱스로 사용하는 해시 테이블(연관배열)이라고 생각할 수 있다.** 대부분의 자바스크립트 엔진은 해시 테이블과 유사하지만 더 나은 방법으로 객체를 구현한다.

- 자바, C++같은 클래스 기반 객체 지향 프로그래밍 언어는 사전에 정의된 클래스를 기반으로 객체(인스턴스)를 생성 → 객체를 생성하기 전, 이미 프로퍼티와 메서드가 정해져 있다. + 객체 생성 후 프로퍼티 삭제, 추가 불가능
- 자바스크립트는 클래스 없이 객체 생성이 가능하므로 동적으로 프로퍼티, 메서드를 추가할 수 있다. → 사용하긴 편리하나 성능면에선 비효율적이다.

→ V8 자바스크립트 엔진에서는 프로퍼티에 접근하기 위해 동적 탐색 대신 **히든 클래스**라는 방식을 사용해 C++ 객체 프로퍼티에 접근하는 정도의 성능을 보장.

`→ 히든클래스 : 자바와 같이 고정된 객체 레이아웃(클래스)과 유사하게 동작`

## 변경 가능한 값

객체는 변경 가능한 값이다.

원시값을 할당한 변수가 기억하는 메모리 공간에 접근하면 원시값에 접근할 수 있다. 즉, 원시 값을 할당한 변수는 원시 값 자체를 값으로 갖는다.

객체를 할당한 **_변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하_**면 참조 값에 접근할 수 있다.

→ 참조값은 생성된 객체가 저장된 메모리 공간의 주소 그 자체이다.

원시값을 할당한 변수를 참조하면 메모리에 저장되어 있는 원시값에 접근한다. 하지만 객체를 할당한 변수를 참조하면 메모리에 저장되어 있는 참조값을 통해 실제 객체에 접근한다.

- 원시 값을 할당한 변수 : `변수는 00값을 갖는다.` `변수의 값은 00다.` 라고 표현한다.
- 객체를 할당한 변수 : `변수는 객체를 참조하고 있다.` / `변수는 객체를 가리키고 있다.`

원시값은 변경 불가능한 값이기 때문에 변수의 값을 변경하기 위해서는 재할당

**객체는 변경 가능한 값. 객체를 할당한 변수는 재할당 없이 객체를 직접 변경할 수 있음!! → 재할당없이 동적으로 추가, 삭제 가능**

변경가능한 값이기에 따르는 구조적 부작용

- 여러개의 식별자가 하나의 객체를 공유할 수 있다.

📍 **얕은복사와 깊은복사**

객체를 프로퍼티 값으로 갖는 객체의 경우

얕은 복사 : 한단게까지 복사

깊은 복사 : 객체에 중첩되어 있는 객체까지 모두 복사

```jsx
const o = [x:{y:1}};

//얕은 복사
const c1 = {...o};
console.log(c1 === o)    //true
console.log(c1.x === o.x)//false

//lodash의 cloneDeep을 사용한 깊은 복사 (npm i lodash -> Node.js)
const _ = require('lodash');

//깊은 복사
const c2 = _.cloneDeep(o);  //require('lodash').cloneDeep(o)
console.log(c2 === o)    //false
console.log(c2.x === o.x)//false
```

얕은 복사와 깊은 복사로 생성된 객체는 원본과는 다른 객체이다. 즉, 원본과 복사본은 참조 값이 다른 별개의 객체다.

- 얕은 복사는 객체에 중첩되어 있는 객체의 경우, **참조 값을 복사**
- 깊은 복사는 객체에 중첩되어 있는 객체까지 모두 복사되어 **원시 값처럼 완전한 복사본**을 만든다.
  - 원시값을 다른 변수에 할당하는 경우 깊은 복사라고 함.

## 참조에 의한 전달

```jsx
var person = {
  name: "Lee",
};

//얕은 복사
var copy = person;
```

객체를 가리키는 변수(원본 person)을 다른 변수에 할당하면 **원본의 참조값이 복사되어 전달**된다.

- 원본의 참조값을 복사해 copy에 저장한다. 원본과 사본이 저장된 메모리 주소는 다르지만 동일한 참조값을 갖는다.
  - 객체가 담긴 메모리 주소를 참조하고 있기 때문!!

**→ 두개의 식별자가 하나의 객체를 공유한다는 것을 의미**

→ 원본, 사본중 어느 한 쪽에서 객체를 변경하면 서로 영향을 주고 받는다.

- 값에 의한 전달과 참조에 의한 전달은 식별자가 기억하는 메모리 공간에 저장되어 있는 값을 복사해 전달하는 것은 동일
